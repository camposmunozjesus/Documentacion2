BASES DE DATOS EN GRAILS
========================
-------------------------
CONECTAR LA BASE DE DATOS
-------------------------
Tenemos los siguientes datos de conexión:
Oracle SQL developer
host: aaaa.bbb.ccc
puerto: 1521
usuario: user
password: pass
servicio: rh (La base de datos)

1) Descargar el driver e incluirlo en la carpeta "/lib" que hay dentro del proyecto:

2) En la clase conf/DataSource.groovy
	dataSource {
		pooled = true
	//    driverClassName = "org.h2.Driver"
	//    username = "sa"
	//    password = ""
		dialect="org.hibernate.dialect.OracleDialect" 
		driverClassName = "oracle.jdbc.OracleDriver"
		username = "user"
		password = "pass"
		...
	// environment specific settings
	environments {
		development {
			dataSource {
				//dbCreate = "update" // one of 'create', 'create-drop', 'update', 'validate', ''
	//            url = "jdbc:h2:mem:devDb;MVCC=TRUE;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE"
				url = "jdbc:oracle:thin:@aaaa.bbb.ccc:1521:rh"
		...
		
Ahora ya se conecta correctamente a la base de datos.

-----------------------------
RECUPERAR DE LA BASE DE DATOS
-----------------------------
Vamos a hacer que el nombre de la clase del controlador sea "TestBasico", por ejemplo, y ataque a una tabla llamada de otra manera, "TEST_YPERSON01".

package sqlconn01

class TestBasicoController {

    def index = {
		redirect (action : CargaDatos)
//		render "eeeeeeeeeeee"
	}
	
	def CargaDatos = {
		println "\n wwwwwwwwwwww"
				
		
		def allData = TestBasico.list();
		for (var in allData) {
			println var.nombrePersona
			println var.apellidoUno
			println "---"

		}
		
		//Ejemplo de recuperar los datos de una persona en conceto:
		def persona = TestBasico.findByNombrePersona("Sergi")
		
		def proyecto1 = "pr"
		[proyecto : proyecto1]
	}
}

package sqlconn01

class TestBasico {

	String nombrePersona
	String apellidoUno
	
//	def apellidoUno
//	def apellidoDos
	
	static mapping = {
		
		table 'TEST_YPERSON01'
		id name:'nombrePersona'
		id generator:'assigned'
		version false
		
		nombrePersona column: 'NOMBRE'
		apellidoUno column: 'PRIAPE'
		
	}
	
    static constraints = {
    }
} 


Datos de ayuda:
Interesante ver:
Mapping de los objetos del dominio:
http://grails.org/doc/2.2.1/ref/Database%20Mapping/table.html

Uso del findBy de Grails:
http://grails.org/doc/2.1.0/ref/Domain%20Classes/findBy.html

Mail:
Te envío un ejemplo de código nuestro:

package rlg

import java.util.ArrayList;
import java.util.Date;

class CodiConciliacio {
	
	String codi
	String descripcio	
	
	static mapping = {
		table 'ZCONCIL01'
		id name:'codi'
		id generator:'assigned'
		version false
		
		codi column: 'CODIGO'
		descripcio column: 'DESCRI'		
		
		sort codi: "asc"
	}
	
	static constraints = {
		codi(size:1..3, blank:false)
		descripcio(size:0..100, blank:false)	
		
	}
}

Aquí ponemos el mapping, que verás el nombre de la tabla, qué campo es el id, id generator significa que el id no es autoincremental, sino que en caso de crear una ocurrencia es el usuario que lo pone a mano, y después el mapeo de los campos de la bbdd.

dataSource {
    pooled = true
//    driverClassName = "org.h2.Driver"
//    username = "sa"
//    password = ""
	dialect="org.hibernate.dialect.OracleDialect" 
	driverClassName = "oracle.jdbc.OracleDriver"
	
	username = "u"
	password = "p"
}
hibernate {
    cache.use_second_level_cache = true
    cache.use_query_cache = false
    cache.region.factory_class = 'net.sf.ehcache.hibernate.EhCacheRegionFactory' // Hibernate 3
//    cache.region.factory_class = 'org.hibernate.cache.ehcache.EhCacheRegionFactory' // Hibernate 4
}

// environment specific settings
environments {
    development {
        dataSource {
            //dbCreate = "update" // one of 'create', 'create-drop', 'update', 'validate', ''
//            url = "jdbc:h2:mem:devDb;MVCC=TRUE;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE"
			url = "jdbc:oracle:thin:@host:puerto:servicio_o_tabla"
        }
    }
    test {
        dataSource {
//            dbCreate = "update"
//            url = "jdbc:h2:mem:testDb;MVCC=..................



-----------------
CLASES DE EJEMPLO
-----------------
CLASE PERSONA
*************
class Persona {

    int pernr
	String sexe
	String cognom1
	String cognom2
	String nom
	String identificacio
	String tipusDocument
	Date naixement
	String codiPostal
	String poblacio
	String provincia
	String pais
	String usuari
	String correu	
	Double horesSemanals	
	
	static mapping = {
		table 'SIG_YPERSON01'
		id name:'pernr'
		id generator:'assigned'
		version false
	
		pernr column: 'pernr'
		sexe column: 'sexo'
		cognom1 column: 'priape'
		cognom2 column: 'segape'
		nom column: 'nombre'
		...
		
		sort cognom1: "asc"	
	
	}
	
    static constraints = {
    }
	
	Lloc getLlocVigent()
	{
		def llocsInstance
		
		// Obtenir el lloc vigent de la persona que no és Carrec academic.
		def query =
		{
			and
			{
				eq("idOcupant", this.pernr)				
				eq("vigent", "S")
			}
		}
		
		try
		{
			llocsInstance = Lloc.createCriteria().list(query)
		}
		catch(Exception e)
		{
			log.error(e.toString())
		}
		if(llocsInstance[0])
			return llocsInstance[0]
		else
			return null
	}
	
}


CLASE LLOC:
***********
import sig.Persona;

class Lloc {

	String codi
	Date dataInici
	Date dataFi
	String vigent
	String descripcioCurta
	String descripcioLlarga
	String unitat
	Integer idOcupant
	Long funcio
	String funcioSpa
	String edifici	
	String tipusJornada
	Double horesSetmanals
	String ambit
	String familia
	String campus
	String espai
	String laboratori
	Integer horesAnuals
	String primerCognom
	String segonCognom
	String nom	

	static mapping = {
		table 'SIG_ZPUESTR01'
		id name:'codi'
		id generator:'assigned'
		version false
			
		codi column: 'codigo'		
		dataInici column: 'fecini'
		dataFi column: 'fecfin' 
		vigent column: 'vigent'
		descripcioCurta column: 'desabr'
		descripcioLlarga column: 'descri'
		unitat column: 'uniorg'		
		idOcupant column: 'pernr'		
		funcio column: 'funcio'
		funcioSpa column: 'funspa'
		edifici column: 'edific'		
		tipusJornada column: 'tipjor'
		horesSetmanals column: 'horsem'
		ambit column: 'ambito'
		familia column: 'famili'
		campus column: 'campus'
		espai column: 'espaci'
		laboratori column: 'labora'
		horesAnuals column: 'joranu'
		primerCognom column: 'priape'
		segonCognom column: 'segape'
		nom column: 'nombre'		
    }
	
	static constraints = {
		codi(blank:false, nullable: false,size:1..8)
		dataInici(blank:false, nullable: false)
		dataFi(blank:false, nullable: false)
		vigent(blank:false, nullable: false,size:1..1)
		descripcioCurta(blank:false, nullable: false,size:1..12)
		descripcioLlarga(blank:true, nullable: true,size:0..40)
		unitat(blank:true, nullable: true,size:0..8)
		idOcupant(blank:true, nullable: true,size:0..8)
		funcio(blank:true, nullable: true,size:0..8)
		funcioSpa(blank:true, nullable: true,size:0..8)
		edifici(blank:true, nullable: true,size:0..8)
		tipusJornada(blank:true, nullable: true,size:0..8)
		horesSetmanals(blank:true, nullable: true)
		ambit(blank:true, nullable: true,size:0..20)
		familia(blank:true, nullable: true,size:0..20)
		campus(blank:true, nullable: true,size:0..8)
		espai(blank:true, nullable: true,size:0..8)
		laboratori(blank:true, nullable: true,size:0..8)
		horesAnuals(blank:true, nullable: true)
		primerCognom(blank:true, nullable: true,size:0..40)
		segonCognom(blank:true, nullable: true,size:0..40)
		nom(blank:true, nullable: true,size:0..40)
	}
	
	boolean isGestor(def user)
	{
		def persona
		def llocsGestionats
		 
		try
		{
			persona = Persona.findByUsuari(user)
			llocsGestionats = UsuariGestor.findAllByPernr(persona.pernr)
			
			for(int i=0; i < llocsGestionats.size();i++)
			{
				if(UsuariGestor.isSuperGestor(persona.pernr) || llocsGestionats[i].codiLloc == this.codi)
					return true
			}
			
		}
		catch(Exception e)
		{
			log.error(e.toString())
		}
			
		return false
		
	}
}



-------------------------------------------------
ORDENAR UN VECTOR RECUPERADO DE UNA BASE DE DATOS
-------------------------------------------------
Utiliza la clse lloc.
Utilizando "sort" después de haber realizado la consulta:
	def persones = Lloc.findAllByPrimerCognom("GARCIA")
	def personesSorted = persones.sort{it.nom}	//nom es una propiedad del objeto del dominio.

Para ordenarlo a la inversa:
	def persones = Lloc.findAllByPrimerCognom("GARCIA")
	def personesSorted = persones.sort{it.nom}.inverse()???????????????????????????????????????????????????????????????????????????????
	

	
------------------------------------------
RECUPERAR DATOS UTILIZANDO MÁS DE UN CAMPO
------------------------------------------
Utiliza la clse lloc.
Utilizando la cláusula findAllBy...
	def segape = Lloc.findAllByNomAndPrimerCognomAndSegonCognom("MARIA DEL CARMEN","TORRENT","SERRA")
	def segape = Lloc.findAllByPrimerCognomAndSegonCognomAndNom("TORRENT","SERRA","MARIA DEL CARMEN")
	def segape = Lloc.findAllByNomAndPrimerCognom("MARIA DEL CARMEN","TORRENT")
	