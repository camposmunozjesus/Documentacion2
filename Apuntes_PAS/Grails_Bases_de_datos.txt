BASES DE DATOS EN GRAILS
========================
-------------------------
CONECTAR LA BASE DE DATOS
-------------------------
Tenemos los siguientes datos de conexión:
Oracle SQL developer
host: aaaa.bbb.ccc
puerto: 1521
usuario: user
password: pass
servicio: rh (La base de datos)

1) Descargar el driver e incluirlo en la carpeta "/lib" que hay dentro del proyecto:

2) En la clase conf/DataSource.groovy
	dataSource {
		pooled = true
	//    driverClassName = "org.h2.Driver"
	//    username = "sa"
	//    password = ""
		dialect="org.hibernate.dialect.OracleDialect" 
		driverClassName = "oracle.jdbc.OracleDriver"
		username = "user"
		password = "pass"
		...
	// environment specific settings
	environments {
		development {
			dataSource {
				//dbCreate = "update" // one of 'create', 'create-drop', 'update', 'validate', ''
	//            url = "jdbc:h2:mem:devDb;MVCC=TRUE;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE"
				url = "jdbc:oracle:thin:@aaaa.bbb.ccc:1521:rh"
		...
		
Ahora ya se conecta correctamente a la base de datos.

Probablemente habría que eliminar "mem" para que mantuviera los cambios en la base de datos.


*************************
------------------------------------
CONECTAR LA BASE DE DATOS POSTGRESQL
------------------------------------
Incluir en el BuildConfig.groovy:
    dependencies {
        // specify dependencies here under either 'build', 'compile', 'runtime', 'test' or 'provided' scopes e.g.
        // runtime 'mysql:mysql-connector-java:5.1.24'
		runtime 'postgresql:postgresql:9.0-801.jdbc4'
    }
	
Archivo Config.groovy:
dataSource {
	pooled = true
	driverClassName = "org.postgresql.Driver"
}
hibernate {
cache.use_second_level_cache=true
cache.use_query_cache=false //cache.use_query_cache=true
cache.provider_class = 'net.sf.ehcache.hibernate.EhCacheProvider'
}

environments {
development {
	dataSource {
		dbCreate = "update" // one of 'create', 'create-drop','update'
		url = "jdbc:postgresql:Pruebas" // o bien url = "jdbc:postgresql://localhost:5432/Pruebas"
					username = "jesus"
					password = "jesus"
	}
}
test {
		dataSource {
		dbCreate = "update"
		url = "jdbc:postgresql:Pruebas"
					username = "jesus"
					password = "jesus"
	}
}
production {
	dataSource {
		dbCreate = "update"
		url = "jdbc:postgresql:Pruebas"
					username = "jesus"
					password = "jesus"
	}
}
}

Teniendo en cuenta que en PostgreSQL se ha creado un usuario llamado "jesus" con contraseña "jesus". PgAdmin -> Roles de entrada -> Nuevo rol de entrada.
Al desplegar "Bases de datos" aparece un icono amarillo de bases de datos llamado "Pruebas", dentro del esquema "test"  y en el apartado de tablas una
tabla llamada "taula".

Si no se indica el esquema se irá al esquema "public".
Hay que dar permisos/poner como propietario al usuario en la BD, el esquema y la tabla.
Pueden haber problemas en el momento de leer la tabla, como indicar que el atributo es un String (suele ser un character varying (numero)).

Para que reconozca el esquema, en static maapping hay que indicar: (con comillas dobles!!!)
    static mapping = {
		table name: "taula", schema: "test"
		...
    }
	
Como solucionar el problema de utilizar PostgrSQL (no encuentra la tabla): http://stackoverflow.com/questions/2034099/psqlexception-error-relation-table-name-does-not-exist
Como incluir el esquema de bases de datos: http://grails.org/doc/2.1.0/ref/Database%20Mapping/table.html

Para poder desplegar la aplicación (archivo WAR) en un Apache Tomcat hay que copiar el archivo jar que contiene los conectores de PostgreSQL, en este
caso postgresql-9.0-801.jdbc4.jar. Se evita el error "No se pudo arrancar la aplicación en trayectoria de contexto apache tomcat".


******************************************************************************************************************************************************
-----------------------------
RECUPERAR DE LA BASE DE DATOS
-----------------------------
Vamos a hacer que el nombre de la clase del controlador sea "TestBasico", por ejemplo, y ataque a una tabla llamada de otra manera, "TEST_YPERSON01".

package sqlconn01

class TestBasicoController {

    def index = {
		redirect (action : CargaDatos)
//		render "eeeeeeeeeeee"
	}
	
	def CargaDatos = {
		println "\n wwwwwwwwwwww"
				
		
		def allData = TestBasico.list();
		for (var in allData) {
			println var.nombrePersona
			println var.apellidoUno
			println "---"

		}
		
		//Ejemplo de recuperar los datos de una persona en conceto:
		def persona = TestBasico.findByNombrePersona("Sergi")
		
		def proyecto1 = "pr"
		[proyecto : proyecto1]
	}
}

package sqlconn01

class TestBasico {

	String nombrePersona
	String apellidoUno
	
//	def apellidoUno
//	def apellidoDos
	
	static mapping = {
		
		table 'TEST_YPERSON01'
		id name:'nombrePersona'
		id generator:'assigned'
		version false
		
		nombrePersona column: 'NOMBRE'
		apellidoUno column: 'PRIAPE'
		
	}
	
    static constraints = {
    }
} 


Datos de ayuda:
Interesante ver:
Mapping de los objetos del dominio:
http://grails.org/doc/2.2.1/ref/Database%20Mapping/table.html

Uso del findBy de Grails:
http://grails.org/doc/2.1.0/ref/Domain%20Classes/findBy.html

Mail:
Te envío un ejemplo de código nuestro:

package rlg

import java.util.ArrayList;
import java.util.Date;

class CodiConciliacio {
	
	String codi
	String descripcio	
	
	static mapping = {
		table 'ZCONCIL01'
		id name:'codi'
		id generator:'assigned'
		version false
		
		codi column: 'CODIGO'
		descripcio column: 'DESCRI'		
		
		sort codi: "asc"
	}
	
	static constraints = {
		codi(size:1..3, blank:false)
		descripcio(size:0..100, blank:false)	
		
	}
}

Aquí ponemos el mapping, que verás el nombre de la tabla, qué campo es el id, id generator significa que el id no es autoincremental, sino que en caso de crear una ocurrencia es el usuario que lo pone a mano, y después el mapeo de los campos de la bbdd.
***FIN DEL MAIL

dataSource {
    pooled = true
//    driverClassName = "org.h2.Driver"
//    username = "sa"
//    password = ""
	dialect="org.hibernate.dialect.OracleDialect" 
	driverClassName = "oracle.jdbc.OracleDriver"
	
	username = "u"
	password = "p"
}
hibernate {
    cache.use_second_level_cache = true
    cache.use_query_cache = false
    cache.region.factory_class = 'net.sf.ehcache.hibernate.EhCacheRegionFactory' // Hibernate 3
//    cache.region.factory_class = 'org.hibernate.cache.ehcache.EhCacheRegionFactory' // Hibernate 4
}

// environment specific settings
environments {
    development {
        dataSource {
            //dbCreate = "update" // one of 'create', 'create-drop', 'update', 'validate', ''
//            url = "jdbc:h2:mem:devDb;MVCC=TRUE;LOCK_TIMEOUT=10000;DB_CLOSE_ON_EXIT=FALSE"
			url = "jdbc:oracle:thin:@host:puerto:servicio_o_tabla"
        }
    }
    test {
        dataSource {
//            dbCreate = "update"
//            url = "jdbc:h2:mem:testDb;MVCC=..................



-----------------
CLASES DE EJEMPLO
-----------------
CLASE PERSONA
*************
class Persona {

    int pernr
	String sexe
	String cognom1
	String cognom2
	String nom
	String identificacio
	String tipusDocument
	Date naixement
	String codiPostal
	String poblacio
	String provincia
	String pais
	String usuari
	String correu	
	Double horesSemanals	
	
	static mapping = {
		table 'SIG_YPERSON01'
		id name:'pernr'
		id generator:'assigned'
		version false
	
		pernr column: 'pernr'
		sexe column: 'sexo'
		cognom1 column: 'priape'
		cognom2 column: 'segape'
		nom column: 'nombre'
		...
		
		sort cognom1: "asc"	
	
	}
	
    static constraints = {
    }
	
	Lloc getLlocVigent()
	{
		def llocsInstance
		
		// Obtenir el lloc vigent de la persona que no és Carrec academic.
		def query =
		{
			and
			{
				eq("idOcupant", this.pernr)				
				eq("vigent", "S")
			}
		}
		
		try
		{
			llocsInstance = Lloc.createCriteria().list(query)
		}
		catch(Exception e)
		{
			log.error(e.toString())
		}
		if(llocsInstance[0])
			return llocsInstance[0]
		else
			return null
	}
	
}


CLASE LLOC:
***********
import sig.Persona;

class Lloc {

	String codi
	Date dataInici
	Date dataFi
	String vigent
	String descripcioCurta
	String descripcioLlarga
	String unitat
	Integer idOcupant
	Long funcio
	String funcioSpa
	String edifici	
	String tipusJornada
	Double horesSetmanals
	String ambit
	String familia
	String campus
	String espai
	String laboratori
	Integer horesAnuals
	String primerCognom
	String segonCognom
	String nom	

	static mapping = {
		table 'SIG_ZPUESTR01'
		id name:'codi'
		id generator:'assigned'
		version false
			
		codi column: 'codigo'		
		dataInici column: 'fecini'
		dataFi column: 'fecfin' 
		vigent column: 'vigent'
		descripcioCurta column: 'desabr'
		descripcioLlarga column: 'descri'
		unitat column: 'uniorg'		
		idOcupant column: 'pernr'		
		funcio column: 'funcio'
		funcioSpa column: 'funspa'
		edifici column: 'edific'		
		tipusJornada column: 'tipjor'
		horesSetmanals column: 'horsem'
		ambit column: 'ambito'
		familia column: 'famili'
		campus column: 'campus'
		espai column: 'espaci'
		laboratori column: 'labora'
		horesAnuals column: 'joranu'
		primerCognom column: 'priape'
		segonCognom column: 'segape'
		nom column: 'nombre'		
    }
	
	static constraints = {
		codi(blank:false, nullable: false,size:1..8)
		dataInici(blank:false, nullable: false)
		dataFi(blank:false, nullable: false)
		vigent(blank:false, nullable: false,size:1..1)
		descripcioCurta(blank:false, nullable: false,size:1..12)
		descripcioLlarga(blank:true, nullable: true,size:0..40)
		unitat(blank:true, nullable: true,size:0..8)
		idOcupant(blank:true, nullable: true,size:0..8)
		funcio(blank:true, nullable: true,size:0..8)
		funcioSpa(blank:true, nullable: true,size:0..8)
		edifici(blank:true, nullable: true,size:0..8)
		tipusJornada(blank:true, nullable: true,size:0..8)
		horesSetmanals(blank:true, nullable: true)
		ambit(blank:true, nullable: true,size:0..20)
		familia(blank:true, nullable: true,size:0..20)
		campus(blank:true, nullable: true,size:0..8)
		espai(blank:true, nullable: true,size:0..8)
		laboratori(blank:true, nullable: true,size:0..8)
		horesAnuals(blank:true, nullable: true)
		primerCognom(blank:true, nullable: true,size:0..40)
		segonCognom(blank:true, nullable: true,size:0..40)
		nom(blank:true, nullable: true,size:0..40)
	}
	
	boolean isGestor(def user)
	{
		def persona
		def llocsGestionats
		 
		try
		{
			persona = Persona.findByUsuari(user)
			llocsGestionats = UsuariGestor.findAllByPernr(persona.pernr)
			
			for(int i=0; i < llocsGestionats.size();i++)
			{
				if(UsuariGestor.isSuperGestor(persona.pernr) || llocsGestionats[i].codiLloc == this.codi)
					return true
			}
			
		}
		catch(Exception e)
		{
			log.error(e.toString())
		}
			
		return false
		
	}
}


CLASE ALUMNO:
*************
class Alumno {

	String nombre
	String apellidoUno
	String apellidoDos
	Integer edad
	
	static belongsTo = [clase: Clase]
	
    static constraints = {
    }
}


<ORDENACIÓN>*******************************************************************************************************************************************
-------------------------------------------------
ORDENAR UN VECTOR RECUPERADO DE UNA BASE DE DATOS
-------------------------------------------------
Utiliza la clse lloc.
Utilizando "sort" después de haber realizado la consulta:
	def persones = Lloc.findAllByPrimerCognom("GARCIA")
	def personesSorted = persones.sort{it.nom}	//nom es una propiedad del objeto del dominio.

Para ordenarlo a la inversa:
	def persones = Lloc.findAllByPrimerCognom("GARCIA")
	def personesSorted = persones.sort{it.nom}.inverse()???????????????????????????????????????????????????????????????????????????????
	

-------------------------
RECUPERAR DATOS Y ORDENAR
-------------------------
Utiliza la calse Alumno.
Código de ejemeplo:
	def alumnos = []
	
	def query =
	{
		and
		{

		}
	}
	
	alumnos = Alumno.createCriteria().list(query)
	alumnos = alumnos.sort{ a,b ->
		a.apellidoUno <=> b.apellidoUno ?: a.edad <=> b.edad
		//?: a.apellidoDos <=> b.apellidoDos  ?: a.nombre <=> b.nombre
	}
	
Suponiendo que la clase Alumno forma parte del dominio, y que tiene los campos edad, nombre, ...
Esta ejecución ordena los elementos obtenidos por el campo apellidoUno, y en el caso de coincidir dos elementos con apellidoUno, el segundo criterio de 
ordenación será el campo edad.


******************************************************************************************************************************************************
------------------------------------------
RECUPERAR DATOS UTILIZANDO MÁS DE UN CAMPO
------------------------------------------
Utiliza la clse lloc.
Utilizando la cláusula findAllBy...
	def segape = Lloc.findAllByNomAndPrimerCognomAndSegonCognom("MARIA DEL CARMEN","TORRENT","SERRA")
	def segape = Lloc.findAllByPrimerCognomAndSegonCognomAndNom("TORRENT","SERRA","MARIA DEL CARMEN")
	def segape = Lloc.findAllByNomAndPrimerCognom("MARIA DEL CARMEN","TORRENT")
	
	
******************************************************************************************************************************************************
---------------------------------------------------------------------
BUSCAR LOS QUE TENGAN UN DETERMINADO CAMPO Y ELIMINAR AL MISMO TIEMPO
---------------------------------------------------------------------
Ejemplo: queremos obtener los diferentes perfiles de trabajador de un edificio. El cargo "Administrativo" puede aparecer varias veces, por lo que
deberemos quedarnos sólo una vez con él.

Hay que realizar una consulta discriminando por edificios, y a su vez encontrar una única vez cada puesto (se consigue con la claúsula projections).

	def resultList = Lloc.createCriteria()list{
		and
		{
			if(filtreEdifici)
			{
				eq("edifici",filtreEdifici)
			}
			
			ne("codi","99999999")
		}
		projections {
			distinct "descripcioLlarga"
		}
	}
	println resultList.size //sirve para saber el tamaño del vector
	
2da forma
*********
Busca todos los que están en el edificio B3 y luego, con unique, se queda con puestos de trabajo únicos, es decir, nunca tendremos dos administrativos, 
dos técnicos, etc ...
	//Se buscan las funciones, código y ámbito en la tabla SIG_ZFUNCIO01
	def query =
	{
		and
		{
			eq("edifici","NDB3")
		}
			
	}
	
	def resultList = Lloc.createCriteria().list(query)
	def result =  resultList.size()
	println resultList.unique{it.funcio}.funcio
	println resultList.unique{it.funcio}.size()
	//println resultList.unique{it.funcio}.descripcioLlarga
	resultList.remove(0)	//Eliminamos el primer elemento pq es null, en este caso.

Impresión por pantalla:	
393
[null, 73, 72]
3

Vemos como de 393 elementos (cuyos únicos 3 valores eran null, 72 y 73) nos quedamos con tres.

Ahora en otra tabla vamos a seleccionar con el código del puesto el nombre del puesto, usaremos un foreach porque desconocemos los valores numéricos:
	def query2 =
	{
		or
		{
//				for(int i=72; i<74; i++){
//					eq("codi",i.toLong())
//				}
//				eq("codi",72.toLong())
//				eq("codi",73.toLong())
			for(val in resultList.unique{it.funcio}.funcio){
				eq("codi",val.toLong())
			}

		}
			
	}
	def resultList2 = Funcio.createCriteria().list(query2)
	
	
******************************************************************************************************************************************************
--------------------------------------
RECUPERAR E IMPRIMIR DATOS CON PRINTLN
--------------------------------------
Si se declaran y recuperan los datos de la siguiente manera:
	def bossesHoresList = []	//rev-20140306
	//rev-20140306 - Aconseguim els tipus de bosses d'hores.
	bossesHoresList = CodiBossaHores.list()
	println "***" + bossesHoresList
	
	se obtiene: ***[rlg.CodiBossaHores : null, rlg.CodiBossaHores : null]
	
Si se utiliza para imprimir:
	println "***" + bossesHoresList.codi
Se imprime la lista de los códigos: ***[001, 002]